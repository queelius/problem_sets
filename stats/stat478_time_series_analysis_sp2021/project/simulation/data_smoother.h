#ifndef __DATA_H__
#define __DATA_H__
#include <vector>
#include <exception>
#include <functional>
#include "kbn_sum.h"

using std::invalid_argument;
using std::vector;
using std::pair;
using std::function;

/*
   DataSmoother. Various algorithms to smooth time series data.
   The smoothed data is an estimator of expected values of
   time series data.

   Table 1:
        t	y[t]	S(alpha=.1)
        1	71	 	 	 
        2	70	    71
        3	69	    70.9
        4	68	    70.71
        5	64	    70.44
        6	65	    69.80
        7	72	    69.32
        8	78	    69.58
        9	75	    70.43
        10	75	    70.88
        11	75	    71.29
        12	70	    71.67

	Table 1 is generated by the following program:
		std::vector<long double> ys{ 71, 70, 69, 68, 64, 65, 72, 78, 75, 75, 75, 70 };
		DataSmoother<long double> smoother(ys);
		auto yss = smoother.exponential_smoothing(0.1);
 */

template <typename T>
class DataSmoother
{
public:
    typedef typename vector<T>::size_type size_type;

    DataSmoother(const vector<T>& data) : _data(data) {};

    size_type size() const
    {
        return _data.size();
    };

    vector<long double> exponential_smoothing(long double alpha)
    {
        vector<long double> s(size());

        s[0] = _data[0];
        for (size_type i = 1; i < size(); ++i)
        {
            s[i] = alpha * _data[i] + (1.0L - alpha) * s[i - 1];
        }
        return s;
    };

    function<long double(unsigned int)> predict(long double alpha, long double beta)
    {
        return [auto sb = double_exponential_smoothing(alpha, beta)](unsigned int n)
        {
            if (n < sb.size())
                return sb[n].second;
                
            return sb.back().first + sb.back().second * (n - sb.size() + 1);
        };
    };

    vector<pair<long double, long double>> double_exponential_smoothing(
        long double alpha,
        long double beta)
    {
        vector<pair<long double, long double>> sb(size());

        sb[1].first = _data[1];
        sb[1].second = _data[1] = _data[0];
        for (size_type i = 2; i < size(); ++i)
        {
            sb[i].first = alpha * _data[i] + (1.0L - alpha) * (sb[i - 1].first + sb[i - 1].second);
            sb[i].second = beta * (sb[i].first - sb[i - 1].first) + (1 - beta) * sb[i - 1].second;
        }

        return sb;
    };


    vector<T>& data() const
    {
        return _data;
    };

    // returns a simple moving average of the data with a window
    // size n of size size() - n + 1.
    //
    // the kth element of the smoothed data is an estimator of
    // the expected value of the (k - n)-th time series
    // value.
    vector<long double> simple_moving_average(unsigned int n)
    {
        if (n > size())
            throw invalid_argument("[DataSmoother::simple_moving_average(unsigned int)] n > size()");

        vector<long double> avg(size() - n + 1);
        alex::math::kbn_sum<long double> sum;
        for (size_t i = 0; i < n; ++i)
        {
            sum += _data[i];
        }
        avg[0] = sum() / n;

        for (size_type i = n; i < size(); ++i)
        {
            sum += -static_cast<long double>(_data[i - n]);
            sum += _data[i];
            avg[i - n + 1] = sum() / n;
        }

        return avg;
    };

    vector<long double> simple_centered_moving_average(unsigned int n)
    {
        if (n > size())
            throw invalid_argument("[DataSmoother::simple_centered_moving_average(unsigned int)] n > size()");

        return DataSmoother<long double>(
            simple_moving_average(2)).simple_moving_average(n);

    };

    long double median()
    {
        return simple_moving_median(size()).front();
    };

    long double mean()
    {
        return simple_moving_average(size()).front();
    };

    vector<T> simple_moving_median(unsigned int n)
    {
        if (n > size())
            throw invalid_argument("[DataSmoother::simple_moving_median(unsigned int)] n > size()");

        auto m = size() - n + 1;
        vector<T> med(m);

        auto start = _data.begin();
        auto end = _data.begin() + n;
        for (size_type i = 0; i < m; ++i)
        {
            auto tmp = vector<T>(start, end);
            std::nth_element(tmp.begin(), tmp.begin() + n / 2, tmp.end());
            med[i] = tmp[n / 2];
            ++start;
            ++end;
        }
        
        return med;
    };

private:
    vector<T> _data;
};

#endif